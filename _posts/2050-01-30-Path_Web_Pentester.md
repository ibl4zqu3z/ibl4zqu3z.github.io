---
title: "Path Web Pentester HTB Academy"
date: 2026-01-30
header:
  image: /assets/images/guias/path_web_pentester.png
  teaser: /assets/images/guias/path_web_pentester.png
excerpt: "Review sobre el Path Web Pentester de Hack The Box."
excerpt_separator: "<!--more-->"
categories:
  - guias
#tags: [shellshock, cgi, bash, cve-2014-6271, linux, pentesting]
---


### Por qué me metí en este path

Hay que decir que vengo de un perfil muy práctico: años de TI, laboratorios, máquinas resueltas y writeups reproducibles. 

En web, casi siempre terminaba llegando a impacto (acceso a datos, ejecución remota, o toma del servidor), pero con un patrón repetido: intuición + enumeración agresiva + prueba/error. Lo que me faltaba era una ruta cerrada que me obligara a estandarizar metodología, a justificar cada hipótesis con tráfico real y a producir evidencia con calidad de informe.

Este path encaja exactamente ahí: base sólida, técnica aplicada y un recorrido completo desde reconocimiento hasta explotación y comunicación del hallazgo.

### Qué es exactamente el Web Penetration Tester Job Role Path

HTB Academy lo presenta como un recorrido para entrar en pentesting web con poca o nula experiencia previa, cubriendo conceptos de evaluación, tácticas de ataque y una metodología de trabajo, con práctica y ejercicios interactivos. El objetivo explícito es pasar por todas las etapas típicas: reconocimiento, identificación de vulnerabilidades, explotación, documentación y comunicación al cliente.

A nivel de estructura, el path lista 20 módulos y un volumen alto de secciones (279), con una dificultad global marcada como Medium.

### De qué va cada módulo del path Web Penetration Tester (y qué me dejó)

1) **Web Requests**
   
   Me mete de lleno en HTTP: estructura de requests/responses y cómo las apps se comunican con el backend. A partir de aquí dejo de “mirar páginas” y empiezo a operar por tráfico y estados.

2) **Introduction to Web Applications**
   
   Aterriza en cómo funcionan las aplicaciones web desde perspectiva de seguridad: componentes, flujo y superficies típicas. Me sirve para construir un modelo mental consistente antes de tocar herramientas.

3) **Using Web Proxies**
   
   Entrena el uso de frameworks de pentesting web (Burp Suite y OWASP ZAP). Me obliga a trabajar con repetibilidad, control de variables y evidencias trazables.

4) **Information Gathering – Web Edition**
   
   Reconocimiento web activo y pasivo: DNS, crawling, archivos históricos, headers y fingerprinting tecnológico. Me fija un proceso para reducir incertidumbre antes de explotar.

5) **Web Fuzzing**
   
   Técnicas y herramientas de fuzzing para descubrir funcionalidad oculta y debilidades. Me disciplina a fuzzear con intención (hipótesis → prueba → verificación), no por volumen.

6) **JavaScript Deobfuscation**
   
   Fundamentos para deobfuscar JavaScript y entender su propósito. Me entrena a tratar el front-end como fuente de rutas, lógica y señales operativas.

7) **Cross-Site Scripting (XSS)**
   
   Identificación y explotación de XSS, con foco en el impacto cuando se encadena con otras vulnerabilidades. Me obliga a pensar en contexto de inyección y en escenarios de compromiso real.

8) **SQL Injection Fundamentals**
   
   Base de SQLi: cómo se abusa para bypass de auth, exfiltración o incluso ejecución en servidor según el caso. Me hace pasar de “payloads sueltos” a razonamiento sobre backend y resultados observables.

9) **SQLMap Essentials**
   
   Uso de SQLMap desde detección hasta enumeración avanzada y extracción de datos. Me deja claro cuándo automatizar y qué evidencias mínimas necesito para que sea defendible en informe.

10) **Command Injections**
   
   Identificación/explotación de command injection y bypass de filtros/mitigaciones. Me aporta metodología para estabilizar explotación y evitar quedarme en “parece que ejecuta”.

11) **File Upload Attacks**
   
   Ataques por subida arbitraria de ficheros: de ejecución de comandos a control del servidor y acceso a datos. Me fuerza a dominar validaciones, transformaciones y vectores de ejecución tras la subida.

12) **Server-side Attacks**
   
   Bugs server-side con foco en SSRF, SSTI y SSI; impacto en disclosure y RCE. Aquí sube la dificultad porque exige modelar el backend, no solo el input.

13) **Login Brute Forcing**
   
   Técnicas de fuerza bruta y herramientas (Hydra/Medusa) aplicadas a distintos escenarios (SSH/FTP/forms web), junto a la importancia de contraseñas robustas. Me estructura el brute force como operación controlada (tasa, señales, lockouts).

14) **Broken Authentication**
   
   Fallos de identificación/autenticación (referenciado a OWASP Top 10 2021). Me obliga a romper flujos: estados, sesiones, reseteos, lógica de autenticación y consecuencias reales.

15) **Web Attacks**
   
   Tres vulnerabilidades comunes: HTTP Verb Tampering, IDOR y XXE; identificar, explotar y prevenir. Me deja un “kit” de pruebas para control de acceso y parsers que en entornos reales aparece constantemente.

16) **File Inclusion**
   
   Visión práctica de inclusión de ficheros como vulnerabilidad frecuente y fácil de pasar por alto. Me afina el ojo para cadenas de ataque donde la funcionalidad “legítima” se convierte en primitiva de lectura/ejecución.

17) **Attacking GraphQL (Mini-Modulo)**
   
   GraphQL como alternativa a REST y cómo una mala configuración deriva en disclosure, SQLi o IDOR. Me enseña a atacar APIs por su capa de consulta y por exposición de esquema/datos.

18) **API Attacks**
   
   Ataques a APIs con foco explícito en OWASP API Security Top 10 (2023). Me consolida un enfoque “API-first”: autorización a nivel objeto, exposición de datos y fallos de diseño como superficie principal.

19) **Attacking Common Applications**
   
   Enumeración y ataque de aplicaciones comunes (CMS, portales internos, apps custom), insistiendo en que la misma app cambia por parches/misconfigs. Me mejora la rapidez de diagnóstico al caer en stacks repetidos.

20) **Bug Bounty Hunting Process**
   
   Proceso de bug bounty para trabajar organizado y comunicar hallazgos de forma profesional y efectiva. Me aterriza el estándar de reporte orientado a receptor: claridad, pruebas y reproducibilidad.

### Cómo está construido: de HTTP “de verdad” a explotación y reporte

1) Fundamentos operativos: ver la web como tráfico, no como páginas

Arranca con Web Requests, Introduction to Web Applications y Using Web Proxies.
Aquí es donde el enfoque me cambió más rápido: dejé de “mirar una web” y empecé a “leer un sistema” a través de request/response, estados, cookies, cabeceras, parámetros, redirects y flujos. El módulo de proxies termina de fijar la disciplina: reproducibilidad, comparativas, manipulación controlada y trazabilidad.

2) Recon y descubrimiento: reducir incertidumbre con señales débiles

El bloque de Information Gathering - Web Edition, Web Fuzzing y JavaScript Deobfuscation fuerza una idea simple: si no sabes qué superficie real existe, todo lo demás es azar.
Lo más útil fue convertir el reconocimiento en un proceso: fuentes pasivas/activas, fingerprinting, crawling, archivos históricos, y luego fuzzing con intención (no “tirar diccionarios”, sino generar hipótesis: endpoints, parámetros, extensiones, rutas, verbos). La parte de JavaScript no es adorno; es el recordatorio de que muchas veces la verdad está en el cliente: rutas internas, validaciones, formatos, tokens y lógica.

3) Vulnerabilidades core: lo común que sigue comprometiendo sistemas

Aquí el path entra en el “pan y mantequilla” del pentesting web: XSS, SQL Injection Fundamentals, SQLMap Essentials, Command Injections, File Upload Attacks, File Inclusion.
La ganancia real no fue aprender qué es cada cosa, sino interiorizar patrones de identificación y explotación sin depender de magia:

En XSS, el salto mental fue tratar el contexto (HTML/atributo/JS/CSS) como parte de la explotación, no un detalle.

En SQLi, pasar de “payloads sueltos” a razonamiento sobre consultas, errores, tiempos, enumeración y rutas a impacto.

SQLMap aparece como herramienta, pero también como lección de límites: sirve si sabes qué estás confirmando y qué evidencia necesitas.

En command injection y file upload, el path empuja a pensar en bypasses, validaciones incompletas, transformaciones en servidor y el ciclo “subo → ejecuto → estabilizo”.

4) Server-side y fallos de lógica: cuando el bug no es “una cadena peligrosa”

El módulo Server-side Attacks (SSRF/SSTI/SSI) y el de Broken Authentication son la parte donde la dificultad sube de forma natural: menos firmas, más modelado del sistema.
Aquí se nota si alguien es “operador” o “pasa pantallas”. En autenticación, por ejemplo, no es memorizar OWASP: es aprender a romper flujos (reseteos, sesiones, tokens, estados intermedios) y a demostrar impacto consistente. El propio path relaciona “Broken Authentication” con OWASP Top 10 2021 y su categoría de fallos de identificación/autenticación.

Este bloque se completa con Login Brute Forcing y Web Attacks (verb tampering, IDOR, XXE).
La mejora aquí fue operativa: automatización con control, detección de puntos de control de acceso y explotación de inconsistencias (métodos HTTP, referencias directas, parsers XML).

5) APIs modernas: dejar de tratar las APIs como “otra web”

Los módulos de Attacking GraphQL y API Attacks son el puente a lo que más aparece hoy en entornos reales: APIs extensas, móviles, integraciones, microservicios.
El path ancla API Attacks en el OWASP API Security Top 10 - 2023, lo cual obliga a pensar en autorización a nivel objeto/propiedad, autenticación y exposición de datos como problemas de diseño, no solo de input validation.

Cierra con Attacking Common Applications y Bug Bounty Hunting Process.
Aquí el aprendizaje fue más “de campo”: enumerar y atacar aplicaciones típicas (portales, CMS, stacks comunes) y convertir hallazgos en reportes accionables.

### Dificultad real: dónde se nota el salto

La etiqueta de dificultad de los módulos cuenta una historia clara: el path empieza en Fundamental/Easy y se consolida en Medium cuando entran inyecciones, server-side bugs, autenticación y APIs.

En mi caso, lo que más fricción generó no fue “entender el concepto”, sino:

- Mantener evidencia limpia mientras iteraba bypasses (command injection, uploads).
- Separar señal de ruido en fuzzing (respuestas “parecidas” que no significan nada).
- Modelar flujos de auth y sesión sin asumir cómo “debería” funcionar.
- En APIs, demostrar impacto sin UI: construir PoCs con requests, correlaciones y estados.

### Qué aprendí que sí me hizo mejor pentester

- Metodología reproducible: cada hallazgo apoyado por tráfico, condiciones y una cadena de pasos coherente, no por intuición.

- Dominio de proxies como herramienta principal (no solo interceptar): comparar, automatizar, marcar estados, aislar variables y producir evidencia.

- Recon y discovery con intención: construir superficie real antes de explotar.

- Deobfuscación y lectura de cliente como parte del proceso estándar, no como excepción.

- Explotación orientada a impacto: pasar de “existe” a “qué permite” (datos, ejecución, pivot interno, compromisos encadenados).

- Mentalidad API-first: autorización y exposición como problemas de diseño, alineado con OWASP API Top 10 2023.

- Comunicación: el path insiste en documentación y reporte profesional, no solo en “conseguir shell”.

### Puntos fuertes y débiles (como experiencia)

#### Fuertes

- Estructura completa de extremo a extremo: de requests a reporte.
- Mucho “hacer” y poca teoría decorativa.
- Cobertura realista de APIs y GraphQL, alineada con amenazas actuales.

#### Débiles

- Para alguien que ya llega con base fuerte en web, la parte inicial puede sentirse lenta; es el peaje por estandarizar fundamentos.
- La especialización profunda (white-box, debugging, exploit dev) no está en el núcleo del path.
